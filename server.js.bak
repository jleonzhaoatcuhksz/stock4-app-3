const express = require('express');
const axios = require('axios');
const cors = require('cors');
const { exec } = require('child_process');
const path = require('path');
const Sentiment = require('sentiment');
const sqlite3 = require('sqlite3').verbose();
const sentiment = new Sentiment();

// Initialize SQLite database
const db = new sqlite3.Database('./sentiment.db', (err) => {
  if (err) {
    console.error('Database connection error:', err.message);
  } else {
    console.log('Connected to sentiment database');
    db.run(`CREATE TABLE IF NOT EXISTS sentiment_scores (
      symbol TEXT,
      date TEXT,
      score REAL,
      article_count INTEGER,
      PRIMARY KEY (symbol, date)
    )`);
  }
});

const app = express();
app.use(cors());
app.use(express.static('public'));

// Top 20 NASDAQ stocks by market cap
const NASDAQ_STOCKS = [
  'AAPL', 'MSFT', 'AMZN', 'NVDA', 'GOOGL',
  'META', 'TSLA', 'AVGO', 'PEP', 'COST',
  'CSCO', 'ADBE', 'INTC', 'CMCSA', 'AMD',
  'TXN', 'QCOM', 'AMGN', 'HON', 'INTU'
];

// Scrape endpoint
app.get('/api/news/:symbol', async (req, res) => {
  try {
    const symbol = req.params.symbol.toUpperCase();
    
    if (!NASDAQ_STOCKS.includes(symbol)) {
      return res.status(400).json({ error: 'Invalid NASDAQ symbol' });
    }

    // Use Python scraper to get news data
    // Try multiple ways to find Python executable
    let pythonPath = process.env.PYTHON_PATH || 
                    process.platform === 'win32' ? 'python' : 'python3';
    
    // Verify Python is available
    try {
      execSync(`${pythonPath} --version`);
    } catch (err) {
      return res.status(500).json({ 
        error: 'Python not found',
        message: 'Please install Python and ensure it\'s in your PATH'
      });
    }
    const pythonProcess = exec(`${pythonPath} scraper.py ${symbol}`, 
      { cwd: __dirname, timeout: 15000 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`Python error: ${stderr}`);
          return res.status(500).json({ error: 'Scraping failed', details: stderr });
        }
        
        try {
          const news = JSON.parse(stdout);
          if (Array.isArray(news) && news.length === 0) {
            return res.status(404).json({ error: 'No news found' });
          } else if (news.error) {
            return res.status(500).json({ error: news.error });
          }

          // Add sentiment analysis to each news item
          // Enhanced sentiment scoring with more keywords
          const customWords = {
            // Strong positive terms (score 3-5)
            'beating': 4, 'surge': 4, 'plunge': -4, 'rally': 3, 'boom': 4, 'soar': 4,
            'breakthrough': 4, 'skyrocket': 5, 'explode': 4, 'dominance': 3,
            'revolution': 4, 'game-changer': 4, 'unstoppable': 4, 'phenomenal': 4,
            
            // Moderate positive terms (score 2)
            'comeback': 2, 'growth': 2, 'profit': 2, 'gain': 2, 'rise': 2, 
            'record': 2, 'innovation': 2, 'leader': 2, 'momentum': 2, 'upside': 2,
            'potential': 2, 'opportunity': 2, 'advantage': 2, 'strengthen': 2,
            
            // Financial fundamentals (score 1-2)
            'dividend': 2, 'yield': 1, 'premium': 1, 'valuation': 1, 'earnings': 2,
            'revenue': 2, 'margin': 2, 'ROI': 2, 'P/E': 1, 'cashflow': 2,
            'balance sheet': 1, 'liquidity': 1, 'solvency': 1, 'efficiency': 1,
            
            // Strong negative terms (score -3 to -5)
            'crash': -4, 'collapse': -5, 'meltdown': -4, 'disaster': -4,
            'catastrophe': -5, 'doomed': -4, 'failure': -3, 'bankruptcy': -5,
            
            // Moderate negative terms (score -1 to -2)  
            'drop': -2, 'fall': -2, 'loss': -2, 'decline': -2, 'slump': -2,
            'dip': -1, 'volatile': -2, 'risk': -2, 'warning': -2, 'cut': -2,
            'reduce': -1, 'short': -3, 'overvalued': -2, 'weakness': -2,
            'threat': -2, 'concern': -1, 'challenge': -1, 'pressure': -1,
            
            // Market sentiment indicators
            'bullish': 3, 'bearish': -3, 'neutral': 0, 'buy': 4, 'sell': -4,
            'hold': 0, 'outperform': 3, 'underperform': -3, 'upgrade': 3,
            'downgrade': -3, 'recommend': 2, 'avoid': -3, 'overweight': 2,
            'underweight': -2, 'target': 1, 'accumulate': 2, 'reduce': -2,
            
            // Technical analysis terms
            'support': 1, 'resistance': -1, 'breakout': 2, 'breakdown': -2,
            'trend': 1, 'reversal': 0, 'consolidation': 0, 'oversold': 1,
            'overbought': -1, 'rally': 3, 'correction': -2, 'rebound': 2,
            
            // Corporate actions
            'split': 1, 'merger': 1, 'acquisition': 1, 'spin-off': 0,
            'bankruptcy': -5, 'delisting': -4, 'IPO': 1, 'SPAC': 0,
            
            // Analyst ratings
            'strong buy': 5, 'buy': 4, 'outperform': 3, 'hold': 0,
            'underperform': -3, 'sell': -4, 'strong sell': -5
          };
          
          const analyzedNews = news.map(item => {
            const sentimentResult = sentiment.analyze(item.title);
            
            // Apply custom scoring
            let customScore = 0;
            const customKeywords = [];
            for (const [word, score] of Object.entries(customWords)) {
              if (item.title.toLowerCase().includes(word)) {
                customScore += score;
                customKeywords.push(word);
              }
            }
            
            const finalScore = sentimentResult.score + customScore;
            const allKeywords = [
              ...new Set([
                ...sentimentResult.positive,
                ...sentimentResult.negative,
                ...customKeywords
              ])
            ].filter(k => k.length > 3); // Filter out short words
            
            console.log('Sentiment analysis for:', item.title);
            console.log('Base score:', sentimentResult.score);
            console.log('Custom score:', customScore);
            console.log('Final score:', finalScore);
            console.log('Keywords:', [...sentimentResult.positive, ...sentimentResult.negative, ...customKeywords]);
            
            return {
              ...item,
              sentiment: {
                score: finalScore,
                comparative: sentimentResult.comparative,
                positive: sentimentResult.positive,
                negative: sentimentResult.negative,
                keywords: [...new Set([...sentimentResult.positive, ...sentimentResult.negative, ...customKeywords])]
              }
            };
          });
          
          res.json({ symbol, news: analyzedNews });
        } catch (e) {
          console.error('Failed to parse scraped data:', e);
          res.status(500).json({ error: 'Failed to parse scraped data', details: e.message });
        }
      }
    );
  } catch (error) {
    console.error('Server error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Sentiment analysis endpoint
app.get('/api/sentiment/:symbol', async (req, res) => {
  try {
    const symbol = req.params.symbol.toUpperCase();
    
    if (!NASDAQ_STOCKS.includes(symbol)) {
      return res.status(400).json({ error: 'Invalid NASDAQ symbol' });
    }

    // Get news data first
    const newsResponse = await axios.get(`http://localhost:${PORT}/api/news/${symbol}`);
    const newsData = newsResponse.data.news;

    // Calculate overall sentiment
    const totalScore = newsData.reduce((sum, item) => sum + item.sentiment.score, 0);
    const avgScore = totalScore / newsData.length;

    res.json({
      symbol,
      sentimentScore: avgScore,
      newsCount: newsData.length,
      breakdown: newsData.map(item => ({
        title: item.title,
        score: item.sentiment.score
      }))
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Daily sentiment endpoint with database storage
app.get('/api/daily-sentiment/:symbol', async (req, res) => {
  try {
    const symbol = req.params.symbol.toUpperCase();
    const days = parseInt(req.query.days) || 30;

    if (!NASDAQ_STOCKS.includes(symbol)) {
      return res.status(400).json({ error: 'Invalid NASDAQ symbol' });
    }

    // Check database for existing data
    db.all(
      `SELECT date, score, article_count 
       FROM sentiment_scores 
       WHERE symbol = ? 
       ORDER BY date DESC LIMIT ?`,
      [symbol, days],
      async (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });

        // If we have enough recent data, return it
        if (rows.length >= days) {
          return res.json(rows.reverse());
        }

        // Otherwise fetch new data
        const dailyData = [];
        const date = new Date();
        
        for (let i = 0; i < days; i++) {
          const currentDate = new Date(date);
          currentDate.setDate(date.getDate() - i);
          const dateStr = currentDate.toISOString().split('T')[0];

          // Check if we already have data for this date
          const existing = rows.find(r => r.date === dateStr);
          if (existing) {
            dailyData.push(existing);
            continue;
          }

          // Fetch and analyze news for this date
          const news = await getNewsForDate(symbol, dateStr);
          const scores = news.map(item => analyzeSentiment(item.title));
          const avgScore = scores.reduce((a,b) => a + b, 0) / scores.length;

          // Store in database
          db.run(
            `INSERT OR REPLACE INTO sentiment_scores 
             VALUES (?, ?, ?, ?)`,
            [symbol, dateStr, avgScore, news.length]
          );

          dailyData.push({
            date: dateStr,
            score: avgScore,
            article_count: news.length
          });
        }

        res.json(dailyData.reverse());
      }
    );
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Helper functions
async function getNewsForDate(symbol, date) {
  return new Promise((resolve, reject) => {
    const pythonPath = `"${process.env.USERPROFILE}\\AppData\\Local\\Programs\\Python\\Python313\\python.exe"`;
    exec(`${pythonPath} scraper.py ${symbol} ${date}`, 
      { cwd: __dirname, timeout: 15000 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`Python error: ${stderr}`);
          return reject(new Error('Scraping failed'));
        }
        try {
          const news = JSON.parse(stdout);
          resolve(Array.isArray(news) ? news : []);
        } catch (e) {
          reject(e);
        }
      }
    );
  });
}

function analyzeSentiment(text) {
  const result = sentiment.analyze(text);
  return result.score;
}

// Get available stocks
app.get('/api/stocks', (req, res) => {
  res.json(NASDAQ_STOCKS);
});

app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Get port from command line, environment variable, or default
const getPort = () => {
  if (process.argv[2]) return parseInt(process.argv[2]);
  if (process.env.PORT) return parseInt(process.env.PORT);
  return 3015; // New default port
};

const PORT = getPort();
let server;

function startServer(port, maxAttempts = 5, attempt = 1) {
  return new Promise((resolve, reject) => {
    server = app.listen(port, '0.0.0.0', () => {
      console.log('
=== Server Started ===');
      console.log(`Port: ${port}`);
      console.log(`Access: http://localhost:${port}`);
      console.log(`Network: http://${getLocalIP()}:${port}`);
      console.log('Registered routes:');
      app._router.stack.forEach((middleware) => {
        if (middleware.route) {
          console.log(`- ${middleware.route.stack[0].method.toUpperCase()} ${middleware.route.path}`);
        }
      });
      resolve(port);
    });

    server.on('error', (err) => {
      if (err.code === 'EADDRINUSE') {
        if (attempt >= maxAttempts) {
          console.error(`Failed to start server after ${maxAttempts} attempts`);
          reject(new Error('Could not find available port'));
          return;
        }
        const nextPort = port + 1;
        console.log(`Port ${port} in use, trying ${nextPort}`);
        startServer(nextPort, maxAttempts, attempt + 1)
          .then(resolve)
          .catch(reject);
      } else {
        console.error('Server error:', err);
        reject(err);
      }
    });
  });
}

// Helper to get local IP address
function getLocalIP() {
  const interfaces = require('os').networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === 'IPv4' && !iface.internal) {
        return iface.address;
      }
    }
  }
  return 'localhost';
}

// Wrap server startup in async function
async function startApplication() {
  try {
    const actualPort = await startServer(PORT);
    console.log(`Server successfully started on port ${actualPort}`);
    
    // Verify all routes
    console.log('
Registered routes:');
    app._router.stack.forEach((middleware) => {
      if (middleware.route) {
        console.log(`${middleware.route.stack[0].method.toUpperCase()} ${middleware.route.path}`);
      }
    });
  } catch (err) {
    console.error('Failed to start server:', err);
    process.exit(1);
  }
}

startApplication();